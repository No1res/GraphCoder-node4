{"query_forward_context": "def hydrate_time(nanoseconds, tz=None):\n    \"\"\"Convert nanoseconds to a time in fixed format.\"\"\"\n    pass\n", "query_forward_encoding": [755, 45705, 349, 3084, 1471, 276, 76989, 11, 43628, 5980, 997, 262, 4304, 12281, 20622, 76989, 311, 264, 892, 304, 8521, 3645, 14781, 262, 1522, 198], "query_forward_graph": "{\"directed\": true, \"multigraph\": true, \"graph\": {}, \"nodes\": [{\"nodeType\": \"function_definition\", \"startRow\": 0, \"endRow\": 0, \"sourceLines\": [\"def hydrate_time(nanoseconds, tz=None):\\n\"], \"defSet\": [\"nanoseconds\", \"tz\", \"hydrate_time\"], \"useSet\": [], \"id\": 0}], \"links\": []}", "metadata": {"task_id": "neo4j---neo4j-python-driver/62e60f43d76274f8a4026e28", "repo_id": "neo4j---neo4j-python-driver", "project": "neo4j/neo4j-python-driver", "file_path": "neo4j/_codec/hydration/v1/temporal.py", "lineno": "66", "end_lineno": "82", "code": "def hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :return: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n", "question_id": "62e60f43d76274f8a4026e28", "signature": "def hydrate_time(nanoseconds, tz=None):", "human_label": "Convert nanoseconds to a time in fixed format.", "forward_context_line_list": [0]}, "top_k_context": [["    return Structure(b\"D\", value.toordinal() - get_date_unix_epoch().toordinal())\n\n\ndef hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :returns: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n\n", "    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n", "def hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :returns: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.2542372881355932], ["    :param nanoseconds:\n    :param tz:\n    :returns: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n\n\ndef dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n", "    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n", "def hydrate_time(nanoseconds, tz=None):\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.2545454545454545], ["    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :returns: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n\n\ndef dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n", "    if tz is None:\n", "def hydrate_time(nanoseconds, tz=None):\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.25925925925925924], ["                       1000000000 * value.second + 1000 * value.microsecond)\n    else:\n        raise TypeError(\"Value must be a neo4j.time.Time or a datetime.time\")\n    if value.tzinfo:\n        return Structure(b\"T\", nanoseconds,\n                         int(value.tzinfo.utcoffset(value).total_seconds()))\n    else:\n        return Structure(b\"t\", nanoseconds)\n\n\ndef hydrate_datetime(seconds, nanoseconds, tz=None):\n    \"\"\" Hydrator for `DateTime` and `LocalDateTime` values.\n\n    :param seconds:\n    :param nanoseconds:\n    :param tz:\n    :returns: datetime\n    \"\"\"\n    from pytz import (\n        FixedOffset,\n        timezone,\n", "    \"\"\" Hydrator for `DateTime` and `LocalDateTime` values.\n\n    :param seconds:\n    :param nanoseconds:\n    :param tz:\n    :returns: datetime\n    \"\"\"\n", "def hydrate_datetime(seconds, nanoseconds, tz=None):\n    \"\"\" Hydrator for `DateTime` and `LocalDateTime` values.\n\n    :param seconds:\n    :param nanoseconds:\n    :param tz:\n    :returns: datetime\n    \"\"\"\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.26666666666666666], ["            n = int(nts(s, \"ascii\", \"strict\") or \"0\", 8)\n        except ValueError:\n            raise InvalidHeaderError(\"invalid header\")\n    else:\n        n = 0\n        for i in range(len(s) - 1):\n            n <<= 8\n            n += ord(s[i + 1])\n    return n\n\ndef itn(n, digits=8, format=DEFAULT_FORMAT):\n    \"\"\"Convert a python number to a number field.\n    \"\"\"\n    # POSIX 1003.1-1988 requires numbers to be encoded as a string of\n    # octal digits followed by a null-byte, this allows values up to\n    # (8**(digits-1))-1. GNU tar allows storing numbers greater than\n    # that if necessary. A leading 0o200 byte indicates this particular\n    # encoding, the following digits-1 bytes are a big-endian\n    # representation. This allows values up to (256**(digits-1))-1.\n    if 0 <= n < 8 ** (digits - 1):\n        s = (\"%0*o\" % (digits - 1, n)).encode(\"ascii\") + NUL\n", "    \"\"\"Convert a python number to a number field.\n    \"\"\"\n", "def itn(n, digits=8, format=DEFAULT_FORMAT):\n    \"\"\"Convert a python number to a number field.\n    \"\"\"\n", ["neo4j---neo4j-python-driver", "venv", "Lib", "site-packages", "pip", "_vendor", "distlib", "_backport", "tarfile.py"], 0.2777777777777778], ["\n    :param nanoseconds:\n    :param tz:\n    :returns: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n\n\ndef dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n", "        return t\n", "def hydrate_time(nanoseconds, tz=None):\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.28], ["    \"\"\"\n    return Structure(b\"D\", value.toordinal() - get_date_unix_epoch().toordinal())\n\n\ndef hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :returns: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n", "    from pytz import FixedOffset\n", "def hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :returns: Time\n    \"\"\"\n    from pytz import FixedOffset\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.3125], ["        nanoseconds = (3600000000000 * value.hour + 60000000000 * value.minute +\n                       1000000000 * value.second + 1000 * value.microsecond)\n    else:\n        raise TypeError(\"Value must be a neo4j.time.Time or a datetime.time\")\n    if value.tzinfo:\n        return Structure(b\"T\", nanoseconds,\n                         int(value.tzinfo.utcoffset(value).total_seconds()))\n    else:\n        return Structure(b\"t\", nanoseconds)\n\n\ndef hydrate_datetime(seconds, nanoseconds, tz=None):\n    \"\"\" Hydrator for `DateTime` and `LocalDateTime` values.\n\n    :param seconds:\n    :param nanoseconds:\n    :param tz:\n    :returns: datetime\n    \"\"\"\n    from pytz import (\n        FixedOffset,\n", "def hydrate_datetime(seconds, nanoseconds, tz=None):\n", "def hydrate_datetime(seconds, nanoseconds, tz=None):\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.34615384615384615], ["def dehydrate_date(value):\n    \"\"\" Dehydrator for `date` values.\n\n    :param value:\n    :type value: Date\n    :returns:\n    \"\"\"\n    return Structure(b\"D\", value.toordinal() - get_date_unix_epoch().toordinal())\n\n\ndef hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :returns: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n", "    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :returns: Time\n    \"\"\"\n", "def hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :returns: Time\n    \"\"\"\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.35714285714285715], ["\ndef dehydrate_date(value):\n    \"\"\" Dehydrator for `date` values.\n\n    :param value:\n    :type value: Date\n    :returns:\n    \"\"\"\n    return Structure(b\"D\", value.toordinal() - get_date_unix_epoch().toordinal())\n\n\ndef hydrate_time(nanoseconds, tz=None):\n    \"\"\" Hydrator for `Time` and `LocalTime` values.\n\n    :param nanoseconds:\n    :param tz:\n    :returns: Time\n    \"\"\"\n    from pytz import FixedOffset\n    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n", "def hydrate_time(nanoseconds, tz=None):\n", "def hydrate_time(nanoseconds, tz=None):\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.4583333333333333]], "text_runtime": 17.700077772140503, "graph_runtime": 0}
{"query_forward_context": "def dehydrate_timedelta(value):\n    \"\"\"Use the value in timedelta to generate the Structure class.\"\"\"\n    pass\n", "query_forward_encoding": [755, 409, 88478, 30187, 47954, 3764, 997, 262, 4304, 10464, 279, 907, 304, 43355, 311, 7068, 279, 29696, 538, 14781, 262, 1522, 198], "query_forward_graph": "{\"directed\": true, \"multigraph\": true, \"graph\": {}, \"nodes\": [{\"nodeType\": \"function_definition\", \"startRow\": 0, \"endRow\": 0, \"sourceLines\": [\"def dehydrate_timedelta(value):\\n\"], \"defSet\": [\"dehydrate_timedelta\", \"value\"], \"useSet\": [], \"id\": 0}], \"links\": []}", "metadata": {"task_id": "neo4j---neo4j-python-driver/62e60f3bd76274f8a4026e10", "repo_id": "neo4j---neo4j-python-driver", "project": "neo4j/neo4j-python-driver", "file_path": "neo4j/_codec/hydration/v1/temporal.py", "lineno": "196", "end_lineno": "207", "code": "def dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :return:\n    \"\"\"\n    months = 0\n    days = value.days\n    seconds = value.seconds\n    nanoseconds = 1000 * value.microseconds\n    return Structure(b\"E\", months, days, seconds, nanoseconds)\n", "question_id": "62e60f3bd76274f8a4026e10", "signature": "def dehydrate_timedelta(value):", "human_label": "Use the value in timedelta to generate the Structure class.", "forward_context_line_list": [0]}, "top_k_context": [["\ndef dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :returns:\n    \"\"\"\n    months = 0\n    days = value.days\n    seconds = value.seconds\n    nanoseconds = 1000 * value.microseconds\n    return Structure(b\"E\", months, days, seconds, nanoseconds)\n\n\nif np is not None:\n    _NUMPY_DURATION_UNITS = {\n        \"Y\": \"years\",\n        \"M\": \"months\",\n        \"W\": \"weeks\",\n        \"D\": \"days\",\n", "    nanoseconds = 1000 * value.microseconds\n", "def dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :returns:\n    \"\"\"\n    months = 0\n    days = value.days\n    seconds = value.seconds\n    nanoseconds = 1000 * value.microseconds\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.23529411764705882], ["        value = utc.localize(value)\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"d\", seconds, nanoseconds)\n    elif hasattr(tz, \"zone\") and tz.zone and isinstance(tz.zone, str):\n        # with named pytz time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.zone)\n    elif hasattr(tz, \"key\") and tz.key and isinstance(tz.key, str):\n        # with named zoneinfo (Python 3.9+) time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.key)\n    else:\n        if isinstance(tz, timezone):\n            # offset of the timezone is constant, so any date will do\n            offset = tz.utcoffset(ANY_BUILTIN_DATETIME)\n        else:\n            offset = tz.utcoffset(value)\n        # with time offset\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"F\", seconds, nanoseconds,\n                         int(offset.total_seconds()))\n", "    else:\n", "def dehydrate_datetime(value):\n    tz = value.tzinfo\n    if tz is None:\n    else:\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.25], ["    except KeyError:\n        point = Point(coordinates)\n        point.srid = srid\n        return point\n    else:\n        if len(coordinates) != dim:\n            raise ValueError(\"SRID %d requires %d coordinates (%d provided)\" % (srid, dim, len(coordinates)))\n        return point_class(coordinates)\n\n\ndef dehydrate_point(value):\n    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :returns:\n    \"\"\"\n    dim = len(value)\n    if dim == 2:\n        return Structure(b\"X\", value.srid, *value)\n    elif dim == 3:\n", "    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :returns:\n    \"\"\"\n", "def dehydrate_point(value):\n    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :returns:\n    \"\"\"\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "spatial.py"], 0.25], ["\n    def seconds_and_nanoseconds(dt):\n        if isinstance(dt, datetime):\n            dt = DateTime.from_native(dt)\n        zone_epoch = DateTime(1970, 1, 1, tzinfo=dt.tzinfo)\n        dt_clock_time = dt.to_clock_time()\n        zone_epoch_clock_time = zone_epoch.to_clock_time()\n        t = dt_clock_time - zone_epoch_clock_time\n        return t.seconds, t.nanoseconds\n\n    tz = value.tzinfo\n    if tz is None:\n        # without time zone\n        from pytz import utc\n        value = utc.localize(value)\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"d\", seconds, nanoseconds)\n    elif hasattr(tz, \"zone\") and tz.zone and isinstance(tz.zone, str):\n        # with named pytz time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.zone)\n", "    if tz is None:\n", "def dehydrate_datetime(value):\n    tz = value.tzinfo\n    if tz is None:\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.25806451612903225], ["\n\ndef dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :returns:\n    \"\"\"\n    months = 0\n    days = value.days\n    seconds = value.seconds\n    nanoseconds = 1000 * value.microseconds\n    return Structure(b\"E\", months, days, seconds, nanoseconds)\n\n\nif np is not None:\n    _NUMPY_DURATION_UNITS = {\n        \"Y\": \"years\",\n        \"M\": \"months\",\n        \"W\": \"weeks\",\n", "    seconds = value.seconds\n", "def dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :returns:\n    \"\"\"\n    months = 0\n    days = value.days\n    seconds = value.seconds\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.26666666666666666], ["    return Structure(b\"E\", value.months, value.days, value.seconds, value.nanoseconds)\n\n\ndef dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :returns:\n    \"\"\"\n    months = 0\n    days = value.days\n    seconds = value.seconds\n    nanoseconds = 1000 * value.microseconds\n    return Structure(b\"E\", months, days, seconds, nanoseconds)\n\n\nif np is not None:\n    _NUMPY_DURATION_UNITS = {\n        \"Y\": \"years\",\n        \"M\": \"months\",\n", "    days = value.days\n", "def dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :returns:\n    \"\"\"\n    months = 0\n    days = value.days\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.27906976744186046], ["    \"\"\"\n    return Structure(b\"E\", value.months, value.days, value.seconds, value.nanoseconds)\n\n\ndef dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :returns:\n    \"\"\"\n    months = 0\n    days = value.days\n    seconds = value.seconds\n    nanoseconds = 1000 * value.microseconds\n    return Structure(b\"E\", months, days, seconds, nanoseconds)\n\n\nif np is not None:\n    _NUMPY_DURATION_UNITS = {\n        \"Y\": \"years\",\n", "    months = 0\n", "def dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :returns:\n    \"\"\"\n    months = 0\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.2926829268292683], ["    \"\"\"\n\n    def seconds_and_nanoseconds(dt):\n        if isinstance(dt, datetime):\n            dt = DateTime.from_native(dt)\n        zone_epoch = DateTime(1970, 1, 1, tzinfo=dt.tzinfo)\n        dt_clock_time = dt.to_clock_time()\n        zone_epoch_clock_time = zone_epoch.to_clock_time()\n        t = dt_clock_time - zone_epoch_clock_time\n        return t.seconds, t.nanoseconds\n\n    tz = value.tzinfo\n    if tz is None:\n        # without time zone\n        from pytz import utc\n        value = utc.localize(value)\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"d\", seconds, nanoseconds)\n    elif hasattr(tz, \"zone\") and tz.zone and isinstance(tz.zone, str):\n        # with named pytz time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n", "    tz = value.tzinfo\n", "def dehydrate_datetime(value):\n    tz = value.tzinfo\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.2962962962962963], ["def dehydrate_duration(value):\n    \"\"\" Dehydrator for `duration` values.\n\n    :param value:\n    :type value: Duration\n    :returns:\n    \"\"\"\n    return Structure(b\"E\", value.months, value.days, value.seconds, value.nanoseconds)\n\n\ndef dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :returns:\n    \"\"\"\n    months = 0\n    days = value.days\n    seconds = value.seconds\n    nanoseconds = 1000 * value.microseconds\n", "    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :returns:\n    \"\"\"\n", "def dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :returns:\n    \"\"\"\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.32432432432432434], ["\ndef dehydrate_duration(value):\n    \"\"\" Dehydrator for `duration` values.\n\n    :param value:\n    :type value: Duration\n    :returns:\n    \"\"\"\n    return Structure(b\"E\", value.months, value.days, value.seconds, value.nanoseconds)\n\n\ndef dehydrate_timedelta(value):\n    \"\"\" Dehydrator for `timedelta` values.\n\n    :param value:\n    :type value: timedelta\n    :returns:\n    \"\"\"\n    months = 0\n    days = value.days\n    seconds = value.seconds\n", "def dehydrate_timedelta(value):\n", "def dehydrate_timedelta(value):\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.3333333333333333]], "text_runtime": 17.591068267822266, "graph_runtime": 0}
{"query_forward_context": "def dehydrate_time(value):\n    \"\"\"Use ticks in the Time class to generate the Structure class.\"\"\"\n    pass\n", "query_forward_encoding": [755, 409, 88478, 3084, 3764, 997, 262, 4304, 10464, 31057, 304, 279, 4212, 538, 311, 7068, 279, 29696, 538, 14781, 262, 1522, 198], "query_forward_graph": "{\"directed\": true, \"multigraph\": true, \"graph\": {}, \"nodes\": [{\"nodeType\": \"function_definition\", \"startRow\": 0, \"endRow\": 0, \"sourceLines\": [\"def dehydrate_time(value):\\n\"], \"defSet\": [\"value\", \"dehydrate_time\"], \"useSet\": [], \"id\": 0}], \"links\": []}", "metadata": {"task_id": "neo4j---neo4j-python-driver/62e60f37d76274f8a4026dfd", "repo_id": "neo4j---neo4j-python-driver", "project": "neo4j/neo4j-python-driver", "file_path": "neo4j/_codec/hydration/v1/temporal.py", "lineno": "85", "end_lineno": "103", "code": "def dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :return:\n    \"\"\"\n    if isinstance(value, Time):\n        nanoseconds = value.ticks\n    elif isinstance(value, time):\n        nanoseconds = (3600000000000 * value.hour + 60000000000 * value.minute +\n                       1000000000 * value.second + 1000 * value.microsecond)\n    else:\n        raise TypeError(\"Value must be a neo4j.time.Time or a datetime.time\")\n    if value.tzinfo:\n        return Structure(b\"T\", nanoseconds,\n                         int(value.tzinfo.utcoffset(value).total_seconds()))\n    else:\n        return Structure(b\"t\", nanoseconds)\n", "question_id": "62e60f37d76274f8a4026dfd", "signature": "def dehydrate_time(value):", "human_label": "Use ticks in the Time class to generate the Structure class.", "forward_context_line_list": [0]}, "top_k_context": [["\n\ndef hydrate_date(days):\n    \"\"\" Hydrator for `Date` values.\n\n    :param days:\n    :returns: Date\n    \"\"\"\n    return Date.from_ordinal(get_date_unix_epoch_ordinal() + days)\n\n\ndef dehydrate_date(value):\n    \"\"\" Dehydrator for `date` values.\n\n    :param value:\n    :type value: Date\n    :returns:\n    \"\"\"\n    return Structure(b\"D\", value.toordinal() - get_date_unix_epoch().toordinal())\n\n\n", "def dehydrate_date(value):\n", "def dehydrate_date(value):\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.23809523809523808], ["\n\ndef dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :returns:\n    \"\"\"\n    if isinstance(value, Time):\n        nanoseconds = value.ticks\n    elif isinstance(value, time):\n        nanoseconds = (3600000000000 * value.hour + 60000000000 * value.minute +\n                       1000000000 * value.second + 1000 * value.microsecond)\n    else:\n        raise TypeError(\"Value must be a neo4j.time.Time or a datetime.time\")\n    if value.tzinfo:\n        return Structure(b\"T\", nanoseconds,\n                         int(value.tzinfo.utcoffset(value).total_seconds()))\n    else:\n        return Structure(b\"t\", nanoseconds)\n", "    elif isinstance(value, time):\n", "def dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :returns:\n    \"\"\"\n    if isinstance(value, Time):\n    elif isinstance(value, time):\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.23809523809523808], ["    )\n    if tz is None:\n        return t\n    if isinstance(tz, int):\n        tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n        zone = FixedOffset(tz_offset_minutes)\n    else:\n        zone = timezone(tz)\n    return zone.localize(t)\n\n\ndef dehydrate_datetime(value):\n    \"\"\" Dehydrator for `datetime` values.\n\n    :param value:\n    :type value: datetime or DateTime\n    :returns:\n    \"\"\"\n\n    def seconds_and_nanoseconds(dt):\n        if isinstance(dt, datetime):\n", "def dehydrate_datetime(value):\n", "def dehydrate_datetime(value):\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.23809523809523808], ["    \"\"\" Hydrator for `Duration` values.\n\n    :param months:\n    :param days:\n    :param seconds:\n    :param nanoseconds:\n    :returns: `duration` namedtuple\n    \"\"\"\n    return Duration(months=months, days=days, seconds=seconds, nanoseconds=nanoseconds)\n\n\ndef dehydrate_duration(value):\n    \"\"\" Dehydrator for `duration` values.\n\n    :param value:\n    :type value: Duration\n    :returns:\n    \"\"\"\n    return Structure(b\"E\", value.months, value.days, value.seconds, value.nanoseconds)\n\n\n", "def dehydrate_duration(value):\n", "def dehydrate_duration(value):\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.23809523809523808], ["        point_class, dim = srid_table[srid]\n    except KeyError:\n        point = Point(coordinates)\n        point.srid = srid\n        return point\n    else:\n        if len(coordinates) != dim:\n            raise ValueError(\"SRID %d requires %d coordinates (%d provided)\" % (srid, dim, len(coordinates)))\n        return point_class(coordinates)\n\n\ndef dehydrate_point(value):\n    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :returns:\n    \"\"\"\n    dim = len(value)\n    if dim == 2:\n        return Structure(b\"X\", value.srid, *value)\n", "def dehydrate_point(value):\n", "def dehydrate_point(value):\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "spatial.py"], 0.23809523809523808], ["    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :returns:\n    \"\"\"\n    if isinstance(value, Time):\n        nanoseconds = value.ticks\n    elif isinstance(value, time):\n        nanoseconds = (3600000000000 * value.hour + 60000000000 * value.minute +\n                       1000000000 * value.second + 1000 * value.microsecond)\n    else:\n        raise TypeError(\"Value must be a neo4j.time.Time or a datetime.time\")\n    if value.tzinfo:\n        return Structure(b\"T\", nanoseconds,\n                         int(value.tzinfo.utcoffset(value).total_seconds()))\n    else:\n        return Structure(b\"t\", nanoseconds)\n\n\ndef hydrate_datetime(seconds, nanoseconds, tz=None):\n", "    else:\n", "def dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :returns:\n    \"\"\"\n    if isinstance(value, Time):\n    else:\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.24390243902439024], ["    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n\n\ndef dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :returns:\n    \"\"\"\n    if isinstance(value, Time):\n        nanoseconds = value.ticks\n    elif isinstance(value, time):\n        nanoseconds = (3600000000000 * value.hour + 60000000000 * value.minute +\n                       1000000000 * value.second + 1000 * value.microsecond)\n    else:\n        raise TypeError(\"Value must be a neo4j.time.Time or a datetime.time\")\n    if value.tzinfo:\n        return Structure(b\"T\", nanoseconds,\n                         int(value.tzinfo.utcoffset(value).total_seconds()))\n", "    if isinstance(value, Time):\n", "def dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :returns:\n    \"\"\"\n    if isinstance(value, Time):\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.25], ["    \"\"\"\n\n    def seconds_and_nanoseconds(dt):\n        if isinstance(dt, datetime):\n            dt = DateTime.from_native(dt)\n        zone_epoch = DateTime(1970, 1, 1, tzinfo=dt.tzinfo)\n        dt_clock_time = dt.to_clock_time()\n        zone_epoch_clock_time = zone_epoch.to_clock_time()\n        t = dt_clock_time - zone_epoch_clock_time\n        return t.seconds, t.nanoseconds\n\n    tz = value.tzinfo\n    if tz is None:\n        # without time zone\n        from pytz import utc\n        value = utc.localize(value)\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"d\", seconds, nanoseconds)\n    elif hasattr(tz, \"zone\") and tz.zone and isinstance(tz.zone, str):\n        # with named pytz time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n", "    tz = value.tzinfo\n", "def dehydrate_datetime(value):\n    tz = value.tzinfo\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.25925925925925924], ["    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n\n\ndef dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :returns:\n    \"\"\"\n    if isinstance(value, Time):\n        nanoseconds = value.ticks\n    elif isinstance(value, time):\n        nanoseconds = (3600000000000 * value.hour + 60000000000 * value.minute +\n", "    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :returns:\n    \"\"\"\n", "def dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :returns:\n    \"\"\"\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.2702702702702703], ["    seconds, nanoseconds = map(int, divmod(nanoseconds, 1000000000))\n    minutes, seconds = map(int, divmod(seconds, 60))\n    hours, minutes = map(int, divmod(minutes, 60))\n    t = Time(hours, minutes, seconds, nanoseconds)\n    if tz is None:\n        return t\n    tz_offset_minutes, tz_offset_seconds = divmod(tz, 60)\n    zone = FixedOffset(tz_offset_minutes)\n    return zone.localize(t)\n\n\ndef dehydrate_time(value):\n    \"\"\" Dehydrator for `time` values.\n\n    :param value:\n    :type value: Time\n    :returns:\n    \"\"\"\n    if isinstance(value, Time):\n        nanoseconds = value.ticks\n    elif isinstance(value, time):\n", "def dehydrate_time(value):\n", "def dehydrate_time(value):\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.3]], "text_runtime": 16.43229031562805, "graph_runtime": 0}
{"query_forward_context": "def dehydrate_point(value):\n    \"\"\"The structure class is generated based on the value length.\"\"\"\n    pass\n", "query_forward_encoding": [755, 409, 88478, 6213, 3764, 997, 262, 4304, 791, 6070, 538, 374, 8066, 3196, 389, 279, 907, 3160, 14781, 262, 1522, 198], "query_forward_graph": "{\"directed\": true, \"multigraph\": true, \"graph\": {}, \"nodes\": [{\"nodeType\": \"function_definition\", \"startRow\": 0, \"endRow\": 0, \"sourceLines\": [\"def dehydrate_point(value):\\n\"], \"defSet\": [\"dehydrate_point\", \"value\"], \"useSet\": [], \"id\": 0}], \"links\": []}", "metadata": {"task_id": "neo4j---neo4j-python-driver/62e60f33d76274f8a4026de9", "repo_id": "neo4j---neo4j-python-driver", "project": "neo4j/neo4j-python-driver", "file_path": "neo4j/_codec/hydration/v1/spatial.py", "lineno": "44", "end_lineno": "57", "code": "def dehydrate_point(value):\n    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :return:\n    \"\"\"\n    dim = len(value)\n    if dim == 2:\n        return Structure(b\"X\", value.srid, *value)\n    elif dim == 3:\n        return Structure(b\"Y\", value.srid, *value)\n    else:\n        raise ValueError(\"Cannot dehydrate Point with %d dimensions\" % dim)\n", "question_id": "62e60f33d76274f8a4026de9", "signature": "def dehydrate_point(value):", "human_label": "The structure class is generated based on the value length.", "forward_context_line_list": [0]}, "top_k_context": [["\n__all__ = ['NormalizedVersion', 'NormalizedMatcher',\n           'LegacyVersion', 'LegacyMatcher',\n           'SemanticVersion', 'SemanticMatcher',\n           'UnsupportedVersionError', 'get_scheme']\n\nlogger = logging.getLogger(__name__)\n\n\nclass UnsupportedVersionError(ValueError):\n    \"\"\"This is an unsupported version.\"\"\"\n    pass\n\n\nclass Version(object):\n    def __init__(self, s):\n        self._string = s = s.strip()\n        self._parts = parts = self.parse(s)\n        assert isinstance(parts, tuple)\n        assert len(parts) > 0\n\n", "    pass\n", "class UnsupportedVersionError(ValueError):\n    \"\"\"This is an unsupported version.\"\"\"\n    pass\n", ["neo4j---neo4j-python-driver", "venv", "Lib", "site-packages", "pip", "_vendor", "distlib", "version.py"], 0.23333333333333334], ["class ProxyError(HTTPError):\n    \"\"\"Raised when the connection to a proxy fails.\"\"\"\n\n    def __init__(self, message, error, *args):\n        super(ProxyError, self).__init__(message, error, *args)\n        self.original_error = error\n\n\nclass DecodeError(HTTPError):\n    \"\"\"Raised when automatic decoding based on Content-Type fails.\"\"\"\n\n    pass\n\n\nclass ProtocolError(HTTPError):\n    \"\"\"Raised when something unexpected happens mid-request/response.\"\"\"\n\n    pass\n\n\n#: Renamed to ProtocolError but aliased for backwards compatibility.\n", "    pass\n", "class DecodeError(HTTPError):\n    \"\"\"Raised when automatic decoding based on Content-Type fails.\"\"\"\n    pass\n", ["neo4j---neo4j-python-driver", "venv", "Lib", "site-packages", "pip", "_vendor", "urllib3", "exceptions.py"], 0.25], ["        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"d\", seconds, nanoseconds)\n    elif hasattr(tz, \"zone\") and tz.zone and isinstance(tz.zone, str):\n        # with named pytz time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.zone)\n    elif hasattr(tz, \"key\") and tz.key and isinstance(tz.key, str):\n        # with named zoneinfo (Python 3.9+) time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.key)\n    else:\n        if isinstance(tz, timezone):\n            # offset of the timezone is constant, so any date will do\n            offset = tz.utcoffset(ANY_BUILTIN_DATETIME)\n        else:\n            offset = tz.utcoffset(value)\n        # with time offset\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"F\", seconds, nanoseconds,\n                         int(offset.total_seconds()))\n\n", "        if isinstance(tz, timezone):\n", "def dehydrate_datetime(value):\n    tz = value.tzinfo\n    if tz is None:\n    else:\n        if isinstance(tz, timezone):\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.25], ["        # with named pytz time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.zone)\n    elif hasattr(tz, \"key\") and tz.key and isinstance(tz.key, str):\n        # with named zoneinfo (Python 3.9+) time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.key)\n    else:\n        if isinstance(tz, timezone):\n            # offset of the timezone is constant, so any date will do\n            offset = tz.utcoffset(ANY_BUILTIN_DATETIME)\n        else:\n            offset = tz.utcoffset(value)\n        # with time offset\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"F\", seconds, nanoseconds,\n                         int(offset.total_seconds()))\n\n\nif np is not None:\n    def dehydrate_np_datetime(value):\n", "        else:\n", "def dehydrate_datetime(value):\n    tz = value.tzinfo\n    if tz is None:\n    else:\n        if isinstance(tz, timezone):\n        else:\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.25], ["            raise ValueError(\"SRID %d requires %d coordinates (%d provided)\" % (srid, dim, len(coordinates)))\n        return point_class(coordinates)\n\n\ndef dehydrate_point(value):\n    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :returns:\n    \"\"\"\n    dim = len(value)\n    if dim == 2:\n        return Structure(b\"X\", value.srid, *value)\n    elif dim == 3:\n        return Structure(b\"Y\", value.srid, *value)\n    else:\n        raise ValueError(\"Cannot dehydrate Point with %d dimensions\" % dim)\n\n\n__all__ = [\n", "    dim = len(value)\n", "def dehydrate_point(value):\n    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :returns:\n    \"\"\"\n    dim = len(value)\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "spatial.py"], 0.2564102564102564], ["        point_class, dim = srid_table[srid]\n    except KeyError:\n        point = Point(coordinates)\n        point.srid = srid\n        return point\n    else:\n        if len(coordinates) != dim:\n            raise ValueError(\"SRID %d requires %d coordinates (%d provided)\" % (srid, dim, len(coordinates)))\n        return point_class(coordinates)\n\n\ndef dehydrate_point(value):\n    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :returns:\n    \"\"\"\n    dim = len(value)\n    if dim == 2:\n        return Structure(b\"X\", value.srid, *value)\n", "def dehydrate_point(value):\n", "def dehydrate_point(value):\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "spatial.py"], 0.2857142857142857], ["    except KeyError:\n        point = Point(coordinates)\n        point.srid = srid\n        return point\n    else:\n        if len(coordinates) != dim:\n            raise ValueError(\"SRID %d requires %d coordinates (%d provided)\" % (srid, dim, len(coordinates)))\n        return point_class(coordinates)\n\n\ndef dehydrate_point(value):\n    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :returns:\n    \"\"\"\n    dim = len(value)\n    if dim == 2:\n        return Structure(b\"X\", value.srid, *value)\n    elif dim == 3:\n", "    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :returns:\n    \"\"\"\n", "def dehydrate_point(value):\n    \"\"\" Dehydrator for Point data.\n\n    :param value:\n    :type value: Point\n    :returns:\n    \"\"\"\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "spatial.py"], 0.2857142857142857], ["        value = utc.localize(value)\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"d\", seconds, nanoseconds)\n    elif hasattr(tz, \"zone\") and tz.zone and isinstance(tz.zone, str):\n        # with named pytz time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.zone)\n    elif hasattr(tz, \"key\") and tz.key and isinstance(tz.key, str):\n        # with named zoneinfo (Python 3.9+) time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.key)\n    else:\n        if isinstance(tz, timezone):\n            # offset of the timezone is constant, so any date will do\n            offset = tz.utcoffset(ANY_BUILTIN_DATETIME)\n        else:\n            offset = tz.utcoffset(value)\n        # with time offset\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"F\", seconds, nanoseconds,\n                         int(offset.total_seconds()))\n", "    else:\n", "def dehydrate_datetime(value):\n    tz = value.tzinfo\n    if tz is None:\n    else:\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.2903225806451613], ["    \"\"\"\n\n    def seconds_and_nanoseconds(dt):\n        if isinstance(dt, datetime):\n            dt = DateTime.from_native(dt)\n        zone_epoch = DateTime(1970, 1, 1, tzinfo=dt.tzinfo)\n        dt_clock_time = dt.to_clock_time()\n        zone_epoch_clock_time = zone_epoch.to_clock_time()\n        t = dt_clock_time - zone_epoch_clock_time\n        return t.seconds, t.nanoseconds\n\n    tz = value.tzinfo\n    if tz is None:\n        # without time zone\n        from pytz import utc\n        value = utc.localize(value)\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"d\", seconds, nanoseconds)\n    elif hasattr(tz, \"zone\") and tz.zone and isinstance(tz.zone, str):\n        # with named pytz time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n", "    tz = value.tzinfo\n", "def dehydrate_datetime(value):\n    tz = value.tzinfo\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.2962962962962963], ["\n    def seconds_and_nanoseconds(dt):\n        if isinstance(dt, datetime):\n            dt = DateTime.from_native(dt)\n        zone_epoch = DateTime(1970, 1, 1, tzinfo=dt.tzinfo)\n        dt_clock_time = dt.to_clock_time()\n        zone_epoch_clock_time = zone_epoch.to_clock_time()\n        t = dt_clock_time - zone_epoch_clock_time\n        return t.seconds, t.nanoseconds\n\n    tz = value.tzinfo\n    if tz is None:\n        # without time zone\n        from pytz import utc\n        value = utc.localize(value)\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"d\", seconds, nanoseconds)\n    elif hasattr(tz, \"zone\") and tz.zone and isinstance(tz.zone, str):\n        # with named pytz time zone\n        seconds, nanoseconds = seconds_and_nanoseconds(value)\n        return Structure(b\"f\", seconds, nanoseconds, tz.zone)\n", "    if tz is None:\n", "def dehydrate_datetime(value):\n    tz = value.tzinfo\n    if tz is None:\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_codec", "hydration", "v1", "temporal.py"], 0.3]], "text_runtime": 16.362982273101807, "graph_runtime": 0}
{"query_forward_context": "def keys(self):\n    \"\"\"Returns the __keys property of a class as a List\"\"\"\n    pass\n", "query_forward_encoding": [755, 7039, 1214, 997, 262, 4304, 16851, 279, 1328, 10786, 3424, 315, 264, 538, 439, 264, 1796, 7275, 262, 1522, 198], "query_forward_graph": "{\"directed\": true, \"multigraph\": true, \"graph\": {}, \"nodes\": [{\"nodeType\": \"function_definition\", \"startRow\": 0, \"endRow\": 0, \"sourceLines\": [\"def keys(self):\\n\"], \"defSet\": [\"keys\", \"self\"], \"useSet\": [], \"id\": 0}], \"links\": []}", "metadata": {"task_id": "neo4j---neo4j-python-driver/62e60ed4d76274f8a4026da0", "repo_id": "neo4j---neo4j-python-driver", "project": "neo4j/neo4j-python-driver", "file_path": "neo4j/_data.py", "lineno": "184", "end_lineno": "189", "code": "    def keys(self):\n        \"\"\" Return the keys of the record.\n\n        :return: list of key names\n        \"\"\"\n        return list(self.__keys)\n", "question_id": "62e60ed4d76274f8a4026da0", "signature": "def keys(self):", "human_label": "Returns the __keys property of a class as a List", "forward_context_line_list": [0]}, "top_k_context": [["\n\ndef _find_adapter(registry, ob):\n    \"\"\"Return an adapter factory for `ob` from `registry`\"\"\"\n    types = _always_object(inspect.getmro(getattr(ob, '__class__', type(ob))))\n    for t in types:\n        if t in registry:\n            return registry[t]\n\n\ndef ensure_directory(path):\n    \"\"\"Ensure that the parent directory of `path` exists\"\"\"\n    dirname = os.path.dirname(path)\n    os.makedirs(dirname, exist_ok=True)\n\n\ndef _bypass_ensure_directory(path):\n    \"\"\"Sandbox-bypassing version of ensure_directory()\"\"\"\n    if not WRITE_SUPPORT:\n        raise IOError('\"os.mkdir\" not supported on this platform.')\n    dirname, filename = split(path)\n", "    \"\"\"Ensure that the parent directory of `path` exists\"\"\"\n", "def ensure_directory(path):\n    \"\"\"Ensure that the parent directory of `path` exists\"\"\"\n", ["neo4j---neo4j-python-driver", "venv", "Lib", "site-packages", "pkg_resources", "__init__.py"], 0.23333333333333334], ["                else:\n                    d.append(self[i])\n            return d\n        return list(self)\n\n    def items(self, *keys):\n        \"\"\" Return the fields of the record as a list of key and value tuples\n\n        :returns: a list of value tuples\n        \"\"\"\n        if keys:\n            d = []\n            for key in keys:\n                try:\n                    i = self.index(key)\n                except KeyError:\n                    d.append((key, None))\n                else:\n                    d.append((self.__keys[i], self[i]))\n            return d\n        return list((self.__keys[i], self._super_getitem_single(i))\n", "            d = []\n", "class Record(tuple, Mapping):\n    def items(self, *keys):\n        \"\"\" Return the fields of the record as a list of key and value tuples\n\n        :returns: a list of value tuples\n        \"\"\"\n        if keys:\n            d = []\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_data.py"], 0.23404255319148937], ["                    )\n                except UnicodeDecodeError:\n                    # Wrong UTF codec detected; usually because it's not UTF-8\n                    # but some other 8-bit codec.  This is an RFC violation,\n                    # and the server didn't bother to tell us what codec *was*\n                    # used.\n                    pass\n        return complexjson.loads(self.text, **kwargs)\n\n    @property\n    def links(self):\n        \"\"\"Returns the parsed header links of the response, if any.\"\"\"\n\n        header = self.headers.get('link')\n\n        # l = MultiDict()\n        l = {}\n\n        if header:\n            links = parse_header_links(header)\n\n", "        \"\"\"Returns the parsed header links of the response, if any.\"\"\"\n", "class Response(object):\n    @property\n    def links(self):\n        \"\"\"Returns the parsed header links of the response, if any.\"\"\"\n", ["neo4j---neo4j-python-driver", "venv", "Lib", "site-packages", "pip", "_vendor", "requests", "models.py"], 0.23529411764705882], ["    tmp = tempfile.gettempdir()\n    extracted_path = os.path.join(tmp, member.split('/')[-1])\n    if not os.path.exists(extracted_path):\n        # use read + write to avoid the creating nested folders, we only want the file, avoids mkdir racing condition\n        with atomic_open(extracted_path) as file_handler:\n            file_handler.write(zip_file.read(member))\n    return extracted_path\n\n\n@contextlib.contextmanager\ndef atomic_open(filename):\n    \"\"\"Write a file to the disk in an atomic fashion\"\"\"\n    replacer = os.rename if sys.version_info[0] == 2 else os.replace\n    tmp_descriptor, tmp_name = tempfile.mkstemp(dir=os.path.dirname(filename))\n    try:\n        with os.fdopen(tmp_descriptor, 'wb') as tmp_handler:\n            yield tmp_handler\n        replacer(tmp_name, filename)\n    except BaseException:\n        os.remove(tmp_name)\n        raise\n", "    \"\"\"Write a file to the disk in an atomic fashion\"\"\"\n", "@contextlib.contextmanager\ndef atomic_open(filename):\n    \"\"\"Write a file to the disk in an atomic fashion\"\"\"\n", ["neo4j---neo4j-python-driver", "venv", "Lib", "site-packages", "pip", "_vendor", "requests", "utils.py"], 0.23529411764705882], ["        ))\n        if len(parts) != 2 or '#' in parts[1]:\n            return NO_MATCH_SENTINEL\n\n        # it's a package page, sanitize and index it\n        pkg = safe_name(parts[0])\n        ver = safe_version(parts[1])\n        self.package_pages.setdefault(pkg.lower(), {})[link] = True\n        return to_filename(pkg), to_filename(ver)\n\n    def process_index(self, url, page):\n        \"\"\"Process the contents of a PyPI page\"\"\"\n\n        # process an index page into the package-page index\n        for match in HREF.finditer(page):\n            try:\n                self._scan(urllib.parse.urljoin(url, htmldecode(match.group(1))))\n            except ValueError:\n                pass\n\n        pkg, ver = self._scan(url)  # ensure this page is in the page index\n", "        \"\"\"Process the contents of a PyPI page\"\"\"\n", "class PackageIndex(Environment):\n    def process_index(self, url, page):\n        \"\"\"Process the contents of a PyPI page\"\"\"\n", ["neo4j---neo4j-python-driver", "venv", "Lib", "site-packages", "setuptools", "package_index.py"], 0.23529411764705882], ["    def set(self, key, value, expires=None):\n        if not expires:\n            self.conn.set(key, value)\n        else:\n            expires = expires - datetime.utcnow()\n            self.conn.setex(key, int(expires.total_seconds()), value)\n\n    def delete(self, key):\n        self.conn.delete(key)\n\n    def clear(self):\n        \"\"\"Helper for clearing all the keys in a database. Use with\n        caution!\"\"\"\n        for key in self.conn.keys():\n            self.conn.delete(key)\n\n    def close(self):\n        \"\"\"Redis uses connection pooling, no need to close the connection.\"\"\"\n        pass\n", "        \"\"\"Helper for clearing all the keys in a database. Use with\n        caution!\"\"\"\n", "class RedisCache(BaseCache):\n    def clear(self):\n        \"\"\"Helper for clearing all the keys in a database. Use with\n        caution!\"\"\"\n", ["neo4j---neo4j-python-driver", "venv", "Lib", "site-packages", "pip", "_vendor", "cachecontrol", "caches", "redis_cache.py"], 0.24324324324324326], ["            for key in keys:\n                try:\n                    i = self.index(key)\n                except KeyError:\n                    d.append(None)\n                else:\n                    d.append(self[i])\n            return d\n        return list(self)\n\n    def items(self, *keys):\n        \"\"\" Return the fields of the record as a list of key and value tuples\n\n        :returns: a list of value tuples\n        \"\"\"\n        if keys:\n            d = []\n            for key in keys:\n                try:\n                    i = self.index(key)\n                except KeyError:\n", "        \"\"\" Return the fields of the record as a list of key and value tuples\n\n        :returns: a list of value tuples\n        \"\"\"\n", "class Record(tuple, Mapping):\n    def items(self, *keys):\n        \"\"\" Return the fields of the record as a list of key and value tuples\n\n        :returns: a list of value tuples\n        \"\"\"\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_data.py"], 0.24390243902439024], ["    The first line is number 1.\n\n    Note - the default parsing behavior is to expand tabs in the input string\n    before starting the parsing process.  See :class:`ParserElement.parseString`\n    for more information on parsing strings containing ``<TAB>`` s, and\n    suggested methods to maintain a consistent view of the parsed string, the\n    parse location, and line and column positions within the parsed string.\n    \"\"\"\n    return strg.count(\"\\n\", 0, loc) + 1\n\ndef line(loc, strg):\n    \"\"\"Returns the line of text containing loc within a string, counting newlines as line separators.\n       \"\"\"\n    lastCR = strg.rfind(\"\\n\", 0, loc)\n    nextCR = strg.find(\"\\n\", loc)\n    if nextCR >= 0:\n        return strg[lastCR + 1:nextCR]\n    else:\n        return strg[lastCR + 1:]\n\ndef _defaultStartDebugAction(instring, loc, expr):\n", "    \"\"\"Returns the line of text containing loc within a string, counting newlines as line separators.\n       \"\"\"\n", "def line(loc, strg):\n    \"\"\"Returns the line of text containing loc within a string, counting newlines as line separators.\n       \"\"\"\n", ["neo4j---neo4j-python-driver", "venv", "Lib", "site-packages", "pip", "_vendor", "pyparsing.py"], 0.25], ["                    d.append(None)\n                else:\n                    d.append(self[i])\n            return d\n        return list(self)\n\n    def items(self, *keys):\n        \"\"\" Return the fields of the record as a list of key and value tuples\n\n        :returns: a list of value tuples\n        \"\"\"\n        if keys:\n            d = []\n            for key in keys:\n                try:\n                    i = self.index(key)\n                except KeyError:\n                    d.append((key, None))\n                else:\n                    d.append((self.__keys[i], self[i]))\n            return d\n", "        if keys:\n", "class Record(tuple, Mapping):\n    def items(self, *keys):\n        \"\"\" Return the fields of the record as a list of key and value tuples\n\n        :returns: a list of value tuples\n        \"\"\"\n        if keys:\n", ["neo4j---neo4j-python-driver", "src", "neo4j", "_data.py"], 0.2558139534883721], ["            for filename in cmd.get_outputs():\n                if filename not in outputs:\n                    outputs.append(filename)\n\n        if self.path_file and self.install_path_file:\n            outputs.append(os.path.join(self.install_libbase,\n                                        self.path_file + \".pth\"))\n\n        return outputs\n\n    def get_inputs(self):\n        \"\"\"Returns the inputs of all the sub-commands\"\"\"\n        # XXX gee, this looks familiar ;-(\n        inputs = []\n        for cmd_name in self.get_sub_commands():\n            cmd = self.get_finalized_command(cmd_name)\n            inputs.extend(cmd.get_inputs())\n\n        return inputs\n\n    # -- Predicates for sub-command list -------------------------------\n", "        \"\"\"Returns the inputs of all the sub-commands\"\"\"\n", "class install(Command):\n    def get_inputs(self):\n        \"\"\"Returns the inputs of all the sub-commands\"\"\"\n", ["neo4j---neo4j-python-driver", "venv", "Lib", "site-packages", "setuptools", "_distutils", "command", "install.py"], 0.25806451612903225]], "text_runtime": 16.34844708442688, "graph_runtime": 0}
